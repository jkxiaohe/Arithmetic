package chapter1;

import java.util.Stack;

/**
 * @author xiaozhu
 *		题目：求最大子矩阵的大小
 *		思路：求最大子矩阵的大小，可以转化为对矩阵的每一行勾画出一个条形图，然后对条形图的最大矩形区域面积进行查找，在此过程中要
 *	解决很多个问题，下面一一列举。
 *		1.条形图的问题：
 *			（1）从上到下，统计以当前行为底的情况，绘制条形图，1代表有，0代表空，条形图的最大矩形面积即是数组距阵的面积；
 *			（2）再向下增加的过程中，有一个原则，下一行为1则加1，下一行为0则为0，在该二维数组中，0代表的就是不连续，反应到条形图
 *			上，就是该位置的条形高度为0，而数组中连续的1反应到条形图上自然也是连续的条形；
 *		 条形图的问题证明完毕，以此说明可以使用条形图统计的方法等价的求出二维数组的最大矩形面积。
 *		2.统计方法的问题：
 *				可以采用对每一条进行向左和向右扩容的方法来求解，即：对条形图的每一根柱子，向左边连续的最大扩容能到哪里，向右连续的最大
 *			扩容能到哪里，扩容的原则为：新柱子的高度>=本柱子的高度。
 *				可以对该方法进行简化，即：只向某一个方向进行单方面的扩容查找，其正确的依据为：条形图中的每一条柱子都会进行遍历，所以
 *			每一个柱子即使不向另一个方向扩容查找，通过对条形图的遍历，仍然会满足向另一个方向扩容查找的要求。
 *				考虑每一根柱子最大能扩到多大，这个行为的实质就是找到柱子的左边刚比它小的柱子的位置在哪里，以及右边刚比它小的位置
 *			在哪里，这个过程使用  栈   的方式计算最快。
 *		3.实现方式：
 *				在代码的实现过程中，同时综合了向左找的关键，而条形图每一条柱子是从左向右遍历的，使用栈来存储左边的每一个柱子的高度，
 *			当然，在栈中存储是有规则的；
 *		4.解释栈的存储规则：
 *				栈的存储规则实际上是为了满足柱子向左查找的要求，那么，向左查找的要求为：左边连续的第一个不小于当前柱子的柱子所在的位置，
 *		  使用栈怎么存储呢？小的存栈底，大的存栈顶，遇到比当前栈顶大的，存入；遇到比<=当前栈顶的，弹出；
 *				证明该方法的正确性：
 *				①当前柱子<=栈顶柱子的时候，将栈顶的柱子弹出，并记当前柱子的下标为i，弹出柱子的下标为j，此时栈顶柱子的下标为k，
 *		 那么，对此刻弹出的该柱子求其最左端的扩容大小，(i-1):当前柱子的下标位置，k:弹出的柱子和此刻比它小的那个柱子的下标位置，
 *		(i-1) - k ：即是当前柱子和左边的那个短点之间的距离，在这段范围内，条形图柱子的高度都是满足柱子j的高度的，所以：
 *		[(i-1) -k] * height[j]  : 即是当前弹出的该柱子向左扩容所形成的最大矩形区域的面积；
 *				②能够想通①之后，接下来只要将下一个柱子的下标push进栈中，然后接着按照相同的方法找就可以了；
 *				③最后，可能在入栈的整个柱子中没有被弹完，那么就需要专门对栈进行弹出操作，此刻由于已经遍历完条形图，所以此刻的
 *		i即是height.length，而j，k，接着从栈中弹出即可，既然有值，说明这中间的柱子都是满足>当前柱子的，直接求值；
 *		5.上述方法有个未解决的问题：
 *				当栈为null时，此刻的k值应该如何表示？解决这个问题，可从简单分析开始，第1个柱子的下标为0，若是第一个柱子就被弹出，那么
 *			必然有：i-1 = 0，这是不可能的，无论如何此刻宽度至少有1，所以可令此刻的k=-1，即栈为null时k=-1,当然，这是简单的推断；
 *				具体的论证过程如下：
 *					  首先明确，讨论k有没有值，是在stack非null的情况下，也就是此刻j是有具体值的，所以突然发现这哪用证明啊，糊涂了..........
 *			
 */
public class Case8 {

	public int maxRecSize(int[][] map) {
		/**
		 * 首先将异常情况排除在外
		 * 1.当前数组为null；2.数组的行为0；3.数组的列为0.
		 */
		if(map==null || map.length==0 || map[0].length==0) {
			return 0;
		}
		int maxArea = 0;
		//height数组存储了列的总长度
		int[] height = new int[map[0].length];    
		//对没一行进行迭代，绘制条形图
		for(int i=0 ; i<map.length ; i++) {
			//对每一列进行迭代，绘制条形图上的每一条柱子
			for(int j=0; j<map[0].length; j++) {
				height[j] = map[i][j]==0 ? 0 : height[j]+1;
			}
			//对没一行绘制成的条形图求其矩形的最大面积
			maxArea = Math.max(maxRecFromBottom(height), maxArea);
		}
		return maxArea;
	}
	
	public int maxRecFromBottom(int[] height) {
		/**
		 * 条形图也有异常的存在，判断：1.条形图本为null，2.条形图中一条柱子都没有  :):)偷笑
		 */
		if(height==null || height.length==0) {
			return 0;
		}
		int maxArea = 0;
		Stack<Integer> stack = new Stack<Integer>();
		
		
		
		return 0;
	}
	
}
