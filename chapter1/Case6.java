package chapter1;

import java.util.LinkedList;

/**
 * @author xiaozhu
 *		生成窗口最大值的数组
 *		思路：首先窗口的大小值是固定的，可以使用一个队列来存储窗口中的值，
 *		设数组长度为n，窗口大小为w，则：
 *	对数组进行顺序遍历，将其下标存储到队列中，使用下标的好处：下标是按序增长的，并且使用下标可以直接取出值来进行比较；
 *		将数组中每个数字的下标i放入到队列中的原则：
 *			①每次放入的下标都添加到队尾，目的：最近的数字在队尾，最久的数字在队头，出队时都从队头出，入队时都从队尾入；
 *			②为保证队列中下标的个数<=窗口所容纳的数字大小w，每次都对那些超出窗口的数字下标进行删除，使用方法为：i-w，i代表了
 *		当前遍历到的数组的数字下标位置，(i-w) 以内的数字均为当前相邻的w个数字的下标，<=(i-w) 的下标已经被窗口所忽略，直接从队列
 *		中删除即可，由于窗口是顺序向数组右边移动，所以可以挨个判断删除，使用方法为：队头下表 == (i-w) ,由于顺序移动的特性，可以
 *		使用==号，当然也可以使用<=;
 *			③每次都将窗口中最大数字的下标放在队头的位置，实现方法为：在整个过程中，仅仅是为了获取到窗口中的最大值，那些比它小的
 *		数字可以直接忽略掉，所以在新添加下标时添加条件，判断当前队尾的数字和新数字的大小关系，有：
 *				（1）队尾数字<=新数字，将队尾的数字出队，直到队列中有>新数字为止，或者队列为null，出队不会影响结果的正确性，因为
 *			新加入的下标值肯定大于队列中的所有下标，肯定在窗口当前容纳范围内最靠前的元素，并且是当前窗口所有值中的最大值，那些
 *			小的出队不影响最大值的结果；
 *				（2）队尾数字>新数字，直接将新下标加到队尾上去，反正只要保证对头是最大值的下标即可。
 */
public class Case6 {

	public int[] getMaxWindow(int[] arr,int w) {
		//异常情况的判断：①数组为null，②窗口大小<1，③数组的长度<窗口的大小
		if(arr==null || w<1 || arr.length<w) {
			return null;
		}
		LinkedList<Integer> qmax = new LinkedList<Integer>();
		int[] res = new int[arr.length-w+1];
		int index = 0;
		for(int i=0;i<arr.length;i++) {
			//在判断的时候要保证队列中有值存在
			while(!qmax.isEmpty() && arr[qmax.peekLast()]<=arr[i]) {
				qmax.pollLast();    //将最后的下标出队
			}
			qmax.addLast(i);
			if(qmax.peekFirst() == i-w) {
				qmax.pollFirst();
			}
			//如果达到了窗口的大小，那么开始将结果放入
			if(i>=w-1) {
				res[index++] = arr[qmax.peekFirst()];
			}
		}
		return res;
	}
	
}
